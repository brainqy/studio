
'use server';
/**
 * @fileOverview Generates mock interview questions for a given topic or job description.
 *
 * - generateMockInterviewQuestions - A function that handles question generation.
 * - GenerateMockInterviewQuestionsInput - The input type.
 * - GenerateMockInterviewQuestionsOutput - The return type.
 */

import {ai} from '@/ai/genkit';
import {z} from 'genkit';
import type { GenerateMockInterviewQuestionsInput, GenerateMockInterviewQuestionsOutput, MockInterviewQuestion, InterviewQuestionCategory, InterviewQuestionDifficulty } from '@/types';

const logger = { // Simple logger for server-side visibility
  info: (message: string, ...args: any[]) => console.log(`[AI FLOW INFO] ${message}`, ...args),
  warn: (message: string, ...args: any[]) => console.warn(`[AI FLOW WARN] ${message}`, ...args),
  error: (message: string, ...args: any[]) => console.error(`[AI FLOW ERROR] ${message}`, ...args),
};

const MockInterviewQuestionSchema = z.object({
  id: z.string().describe("Unique identifier for the question."),
  questionText: z.string().describe("The text of the interview question."),
  category: z.string().optional().describe("Category of the question (e.g., Behavioral, Technical, Situational, Analytical, HR)."),
  difficulty: z.enum(['Easy', 'Medium', 'Hard'] as [InterviewQuestionDifficulty, ...InterviewQuestionDifficulty[]]).optional().describe("Difficulty level of the question."),
  // rating: z.number().optional(), // Not typically generated by AI, but could be if AI is asked to rate its own questions
  // comments: z.string().optional(), // Admin comments, not generated by AI
  // createdBy: z.string().optional(), // System or admin ID, not typically part of AI generation output for this flow
  // approved: z.boolean().optional(), // Admin approval, not generated by AI
});

const GenerateMockInterviewQuestionsInputSchema = z.object({
  topic: z.string().describe('The main topic, role, or area for the interview (e.g., "Software Engineering", "Product Management", "Java Backend Developer").'),
  jobDescription: z.string().optional().describe('The full job description text to tailor questions to. If provided, questions will be more specific to the role.'),
  numQuestions: z.number().min(1).max(50).default(5).optional().describe('The desired number of questions to generate (default 5, max 50).'),
  difficulty: z.enum(['easy', 'medium', 'hard']).default('medium').optional().describe('The desired difficulty level of the questions (default medium). This will guide the AI in selecting appropriate questions.'),
  timerPerQuestion: z.number().min(0).max(300).optional().describe('Optional: Suggested time in seconds for answering each question. 0 or undefined means no timer.'),
  questionCategories: z.array(z.string()).optional().describe('Optional: Specific categories of questions to focus on (e.g., ["Technical", "Behavioral"]).'),
});

const GenerateMockInterviewQuestionsOutputSchema = z.object({
  questions: z.array(MockInterviewQuestionSchema).describe("A list of generated mock interview questions."),
});

export async function generateMockInterviewQuestions(
  input: GenerateMockInterviewQuestionsInput
): Promise<GenerateMockInterviewQuestionsOutput> {
  logger.info("Calling generateMockInterviewQuestionsFlow with input:", input);
  try {
    const result = await generateMockInterviewQuestionsFlow(input);
    if (!result || !result.questions) {
        logger.warn("generateMockInterviewQuestionsFlow returned null or no questions. Returning empty questions array.");
        return { questions: [] };
    }
    logger.info(`generateMockInterviewQuestionsFlow returned ${result.questions.length} questions.`);
    return result;
  } catch (flowError: any) {
    logger.error("Error in generateMockInterviewQuestionsFlow execution:", flowError);
    return { questions: [] }; // Return empty questions on error
  }
}

const prompt = ai.definePrompt({
  name: 'generateMockInterviewQuestionsPrompt',
  input: {schema: GenerateMockInterviewQuestionsInputSchema},
  output: {schema: GenerateMockInterviewQuestionsOutputSchema},
  config: { // Added safety settings
    safetySettings: [
      { category: 'HARM_CATEGORY_HARASSMENT', threshold: 'BLOCK_ONLY_HIGH' },
      { category: 'HARM_CATEGORY_HATE_SPEECH', threshold: 'BLOCK_ONLY_HIGH' },
      { category: 'HARM_CATEGORY_SEXUALLY_EXPLICIT', threshold: 'BLOCK_ONLY_HIGH' },
      { category: 'HARM_CATEGORY_DANGEROUS_CONTENT', threshold: 'BLOCK_ONLY_HIGH' },
    ],
  },
  prompt: `You are an expert Interview Question Generator. Your task is to create a set of diverse and relevant mock interview questions based on the provided criteria.

Topic/Role: {{{topic}}}
{{#if jobDescription}}
Job Description:
{{{jobDescription}}}
{{else}}
No specific job description provided. Generate general questions for the topic/role.
{{/if}}
Number of Questions to Generate: {{{numQuestions}}}
Desired Difficulty Level: {{{difficulty}}} (The AI should aim to generate questions of this difficulty, e.g., 'Easy', 'Medium', 'Hard')

{{#if questionCategories.length}}
Focus on generating questions from the following categories:
{{#each questionCategories}}
- {{{this}}}
{{/each}}
If not possible to generate all questions from these categories, supplement with other relevant types.
{{else}}
Include a mix of question types (e.g., Behavioral, Technical, Situational, Analytical, HR) if appropriate for the topic.
{{/if}}

Instructions:
1.  Generate exactly {{{numQuestions}}} questions. If you cannot generate that many relevant questions based on the input, generate as many as you can up to that number.
2.  For each question, assign a 'difficulty' level ('Easy', 'Medium', or 'Hard') that matches the overall desired difficulty ({{{difficulty}}}) as closely as possible. If a specific difficulty isn't obvious, default to 'Medium'.
3.  If a job description is provided, tailor questions to the skills, responsibilities, and technologies mentioned in it.
4.  If no job description, create general questions relevant to the {{{topic}}}.
5.  Assign a 'category' to each question (e.g., Behavioral, Technical, Analytical, HR, Common, Role-Specific, Situational, Problem-Solving). If unsure, use "Common".
6.  Each question should have a unique 'id' (e.g., "q1", "q2", or a more descriptive unique ID like "tech_java_001").
7.  Ensure 'questionText' is clear and concise.
8.  If you cannot generate any relevant questions, return an empty "questions" array in the JSON.

Output strictly in the JSON format defined by the schema. Ensure each question has an 'id', 'questionText', a relevant 'category', and a 'difficulty' field.
Example for empty: { "questions": [] }
`,
});

const generateMockInterviewQuestionsFlow = ai.defineFlow(
  {
    name: 'generateMockInterviewQuestionsFlow',
    inputSchema: GenerateMockInterviewQuestionsInputSchema,
    outputSchema: GenerateMockInterviewQuestionsOutputSchema,
  },
  async (input): Promise<GenerateMockInterviewQuestionsOutput> => {
    logger.info("Flow: Starting generateMockInterviewQuestions with input:", JSON.stringify(input));
    let aiResponse;
    try {
      aiResponse = await prompt(input);
      logger.info("Flow: Raw AI response from prompt:", JSON.stringify(aiResponse));

      if (!aiResponse || !aiResponse.output || !aiResponse.output.questions) {
          logger.warn("Flow: AI prompt did not return any parsable output or questions. Returning empty questions array.");
          return { questions: [] };
      }
      
      const output = aiResponse.output;

      // Ensure IDs are unique and difficulty/category have defaults if AI misses them
      const processedQuestions = output.questions.map((q, index) => {
        const defaultDifficulty = (input.difficulty?.charAt(0).toUpperCase() + input.difficulty!.slice(1)) as InterviewQuestionDifficulty || 'Medium';
        return {
            ...q,
            id: q.id || `gen_q_${Date.now()}_${index + 1}`, // More unique ID
            category: q.category || "Common",
            difficulty: (q.difficulty ? (q.difficulty.charAt(0).toUpperCase() + q.difficulty.slice(1)) : defaultDifficulty) as InterviewQuestionDifficulty,
        };
      });
      logger.info(`Flow: Processed ${processedQuestions.length} questions.`);
      return { questions: processedQuestions };

    } catch (error: any) {
      logger.error("Flow: CRITICAL ERROR during AI prompt execution or processing:", error.message, error.stack);
      if (error.details) logger.error("[AI FLOW CRITICAL ERROR DETAILS] ", error.details);
      return { questions: [] }; // Return empty on error
    }
  }
);
